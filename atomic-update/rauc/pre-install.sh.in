#!/bin/bash
# -*- mode: sh; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
# vim: et sts=4 sw=4

#  SPDX-License-Identifier: LGPL-2.1+
#
#  Copyright © 2019-2022 Collabora Ltd.
#  Copyright © 2019-2020 Valve Corporation.
#
#  This file is part of steamos-customizations.
#
#  steamos-customizations is free software; you can redistribute it and/or
#  modify it under the terms of the GNU Lesser General Public License as
#  published by the Free Software Foundation; either version 2.1 of the License,
#  or (at your option) any later version.

set -e
set -u

#
# Helpers
#

log () { echo >&2 "$@"; }
warn() { echo >&2 "Warning:" "$@"; }
fail() { echo >&2 "Error:" "$@"; exit 1; }

SYMLINKS_DIR=@udev_symlinks_absdir@
PARTSETS_RELDIR=@partsets_reldir@
RAUC_RUNTIME_DIR=@rauc_runtime_dir@
REBOOT_FOR_UPDATE=@reboot_for_update@


#
# Ensure that the UUID of the update is different from the current rootfs
#

# `steamos-image-recipes` is expected to include a UUID text file inside the
# RAUC bundle
target_uuid=
if [[ -f ${RAUC_BUNDLE_MOUNT_POINT}/UUID ]]; then
    target_uuid=$(<"${RAUC_BUNDLE_MOUNT_POINT}/UUID")
elif [[ -f ${RAUC_BUNDLE_MOUNT_POINT}/rootfs.img ]]; then
    target_uuid=$(blkid -o value -s UUID ${RAUC_BUNDLE_MOUNT_POINT}/rootfs.img)
fi

if [[ ${target_uuid} ]]; then
    this_image=$(steamos-bootconf this-image)
    root_uuid=$(blkid -o value -s UUID ${SYMLINKS_DIR}/${this_image}/rootfs)

    log "Current image rootfs UUID: $root_uuid"
    log "Target image rootfs UUID: $target_uuid"

    if [[ ${root_uuid} == ${target_uuid} ]]; then
        fail "Cannot install an image with the same rootfs UUID as the current active one"
    fi
else
    log "Trying to install an update that doesn't provide its UUID, trying to continue anyway"
fi


[ -d "$RAUC_RUNTIME_DIR" ] || fail "RAUC runtime dir does not exist"

#
# We are going to install a new update, remove the eventual info about a
# pending reboot
#

rm -f -- "$REBOOT_FOR_UPDATE"

#
# Check the target partitions for corruption
#

ismounted() {
    local device=$1

    findmnt --real --source "$device" >/dev/null 2>&1
}

remountcmd() {
    local device=$1

    local WHERE=$(findmnt -n --raw --real --source "$device" | cut -f1 -d' ')
    local OPTS=$(findmnt -n --raw --real --source "$device" | cut -f4 -d' ')
    echo "mount -o $OPTS $device $WHERE"
}

fstype() {
    local device="$1"

    blkid -s TYPE -o value "$device"
}

get_parent_device() {

    # Get the parent of a block device, for example:
    # /dev/sda3 -> /dev/sda

    local device=$(realpath "$1")
    [ -b "$device" ] || return

    local devname=$(basename "$device")
    local diskname=$(basename "$(realpath "/sys/class/block/$devname/..")")
    local disk="/dev/$diskname"
    [ -b "$disk" ] || return

    echo "$disk"
}

get_partlabel() {

    # Get the partlabel for a given block device, for example:
    # /dev/sda2 -> efi-A

    local device=$(realpath "$1")
    [ -b "$device" ] || return

    local disk=$(get_parent_device "$device")
    [ -b "$disk" ] || return

    while read -r dev name; do
        if [ "$dev" == "$device" ]; then echo "$name"; return; fi
    done < <(sfdisk -ql -o device,name "$disk" | tail +2)
}

reformat_device_vfat() {
    local device="$1"
    local opts=
    local label=

    device=$(readlink -f "$device")
    if ! [ -b "$device" ]; then
        warn "'$device' is not a block device"
        return
    fi

    if ismounted "$device"; then
        REMOUNTCMD=$(remountcmd "$device")
        umount -v "$device"
    fi

    if ismounted "$device"; then
        umount -v -f "$device"
    fi

    label=$(get_partlabel "$device")
    if [ "$label" ]; then
        opts="$opts -n $label"
    fi

    mkfs.vfat $opts "$device"

    if [ -n "${REMOUNTCMD:-}" ]; then
        $REMOUNTCMD
    fi
}

check_fat() {
    declare -r device="$1"
    declare -r TYPE=$(fstype "$device")

    case "$TYPE" in
        vfat)
            # Everything is okay, we expected this
            log "Found expected VFAT EFI filesystem in ${device}."
            return 0
        ;;
        exfat)
            # Merits at least a warning
            warn "Found unexpected exFAT EFI filesystem in ${device}."
            return 1
        ;;
        ntfs)
            # Things have gone bad
            warn "Found invalid NTFS filesystem in ${device}."
            return 1
        ;;
        *)
            # Things have gone really bad
            warn "Found invalid ${TYPE} filesystem on ${device}."
            return 1
        ;;
    esac
}

log "Detecting 'other' efi partition"

BOOTED_SLOT=$(steamos-bootconf this-image)
declare -r BOOTED_SLOT
PRESERVED_SLOT=
UPDATED_SLOT=

log "Booted into slot $BOOTED_SLOT"

case $BOOTED_SLOT in
    A)
        PRESERVED_SLOT=A
        UPDATED_SLOT=B
        EFI_DEVICE=$(realpath $SYMLINKS_DIR/other/efi)
        ;;
    B)
        PRESERVED_SLOT=B
        UPDATED_SLOT=A
        EFI_DEVICE=$(realpath $SYMLINKS_DIR/other/efi)
        ;;
    *)
        while read -r valid slot x
        do
            case $valid$slot in
                +A)
                    UPDATED_SLOT=B
                    PRESERVED_SLOT=A
                    ;;
                +B)
                    UPDATED_SLOT=A
                    PRESERVED_SLOT=B
                    ;;
            esac
        done < <(steamos-bootconf list-images)
        EFI_DEVICE=$(realpath $SYMLINKS_DIR/$UPDATED_SLOT/efi)
        ;;
esac

WIPE_EFI=false
if check_fat $EFI_DEVICE; then
    if ! fsck.vfat -n $EFI_DEVICE; then
        # Errors found for $EFI_DEVICE
        warn "Found errors for ${EFI_DEVICE}, attempting repair."
        if ! fsck.vfat -a $EFI_DEVICE; then
            # Unfixable errors found for EFI_DEVICE
            warn "Unable to repair ${EFI_DEVICE}, rebuilding filesystem as VFAT."
            WIPE_EFI=true
        fi
    fi
else
    warn "Rebuilding filesystem on $EFI_DEVICE as VFAT."
    WIPE_EFI=true
fi

if $WIPE_EFI; then
    TEMPDIR=$(mktemp -d)
    reformat_device_vfat $EFI_DEVICE
    mount $EFI_DEVICE "$TEMPDIR/mnt"

    # Recreate the partsets
    steamos-partsets "$TEMPDIR/mnt"
    # steamos-partsets doesn't create self and other, just A and B
    rm -f "$TEMPDIR/mnt/self" "$TEMPDIR/mnt/other"
    cp "$TEMPDIR/mnt/$PARTSETS_RELDIR/$UPDATED_SLOT"   "$TEMPDIR/mnt/$PARTSETS_RELDIR/self"
    cp "$TEMPDIR/mnt/$PARTSETS_RELDIR/$PRESERVED_SLOT" "$TEMPDIR/mnt/$PARTSETS_RELDIR/other"

    umount "$TEMPDIR/mnt"
    rm -rf "$TEMPDIR"
fi

ESP_DEVICE=$(realpath $SYMLINKS_DIR/shared/esp)

if check_fat $ESP_DEVICE; then
    if ! fsck.vfat -n $ESP_DEVICE; then
        # Errors found for $ESP_DEVICE
        warn "Found errors for ${ESP_DEVICE}, attempting repair."
        fsck.vfat -a $ESP_DEVICE
    fi
fi

#
# Disable all systemd timers
#

ACTIVE_TIMERS=$RAUC_RUNTIME_DIR/active-timers

systemctl list-units --full --no-legend --type=timer --state=active | \
while read -r service _; do
    [[ -n "$service" ]] || continue
    systemctl stop "$service" >/dev/null
    echo "$service"
done > "$ACTIVE_TIMERS"
