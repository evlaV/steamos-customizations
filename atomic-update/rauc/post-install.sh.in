#!/bin/bash
# -*- mode: sh; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
# vim: et sts=4 sw=4

#  SPDX-License-Identifier: LGPL-2.1+
#
#  Copyright © 2019-2021 Collabora Ltd.
#  Copyright © 2019-2021 Valve Corporation.
#
#  This file is part of steamos-customizations.
#
#  steamos-customizations is free software; you can redistribute it and/or
#  modify it under the terms of the GNU Lesser General Public License as
#  published by the Free Software Foundation; either version 2.1 of the License,
#  or (at your option) any later version.

set -e
set -u

ERR=0 # the error code returned by this script

SYMLINKS_DIR=@udev_symlinks_absdir@
BOOTCONF_RELDIR=@bootconf_reldir@
PARTSETS_RELDIR=@partsets_reldir@
ROOTHASH_RELPATH=@roothash_relpath@
RAUC_RUNTIME_DIR=@rauc_runtime_dir@
REBOOT_FOR_UPDATE=@reboot_for_update@

HOLO_BOOTED_SLOT_SYNC_TRIGGER=/run/holo-booted-slot-sync-trigger

OWD="$(dirname "$(readlink -f "$0")")"

#
# Helpers
#

log () { echo >&2 "$@"; }
warn() { echo >&2 "Warning:" "$@"; }
err () { echo >&2 "Error:" "$@"; rm -f $HOLO_BOOTED_SLOT_SYNC_TRIGGER; ERR=1; }
fail() { echo >&2 "Error:" "$@"; rm -f $HOLO_BOOTED_SLOT_SYNC_TRIGGER; exit 1; }


#
# Re-enable systemd timers
#

ACTIVE_TIMERS=$RAUC_RUNTIME_DIR/active-timers

if [ -e "$ACTIVE_TIMERS" ]; then
    while read -r service; do
        [[ "$service" ]] || continue
        systemctl start "$service"
    done < "$ACTIVE_TIMERS"
fi

rm -f $ACTIVE_TIMERS

#
# Take a slot and the json from steamos-atomupd/manifest.json and make
# a suitable boot menu label, falling back to something generic
#

boot_label () {
    local slot=${1:-\?}
    local blob=${2:-"{}"}
    local version=$(jq -rc '.version' <<<"$blob")
    local product=$(jq -rc '.product' <<<"$blob")
    local buildid=$(jq -rc '.buildid' <<<"$blob")

    case ${buildid}   in (null)            buildid="";      ;; esac
    case ${version}   in (snapshot|null)   version="";      ;; esac
    case ${product,,} in (steamos|null|'') product=SteamOS; ;; esac

    local ident=${version}${version:+-}${buildid}

    echo "${product}-$slot${ident:+-}${ident}"
}

#
# Handle the 'other' efi partition
#

configure_other_efi() {
    local efi=$1
    local keep_slot=$2
    local update_slot=$3
    local bootconf=
    local confdir=
    local partsets=
    local roothash=
    local ident=
    local self_partsets=

    # bootconf needs the partset data now so set it up first:
    partsets=$efi/$PARTSETS_RELDIR
    if ! [ -e "$partsets" ]; then
        self_partsets="/efi/$PARTSETS_RELDIR"
        log "Initializing 'other' efi partsets: '$self_partsets' -> '$partsets'"
        mkdir -p "$partsets"
        cp "$self_partsets/all"    "$partsets/"
        cp "$self_partsets/shared" "$partsets/"

        # the updated slot partset info goes into self,
        # and the preserved slot info goes into other
        # we could just swap self and other, but we want to support
        # updates while the dev slot is booted as well as A/B:
        cp "$self_partsets/$update_slot"  "$partsets/self"
        cp "$self_partsets/$keep_slot"    "$partsets/other"

        if [ -e "$self_partsets/dev" ]; then
            cp "$self_partsets/dev" "$partsets/dev"
        fi
    fi

    ident=$update_slot
    confdir=/esp/$BOOTCONF_RELDIR
    bootconf=$confdir/${ident}.conf

    if ! [ -e "$bootconf" ]; then
        log "Initializing 'other' esp bootconf: '$bootconf'"
        mkdir -p "$confdir"
        steamos-bootconf create --conf-dir "$confdir" --image "$ident" --set title "$ident"
    fi

    roothash=$efi/$ROOTHASH_RELPATH
    if [ -e "$RAUC_UPDATE_SOURCE/roothash" ]; then
        mkdir -p "$(dirname "$roothash")"
        cp -f "$RAUC_UPDATE_SOURCE/roothash" "$roothash"
    fi
}

log "Detecting 'other' efi partition"

declare -r BOOTED_SLOT=$(steamos-bootconf this-image)
UPDATED_SLOT=

log "Booted into slot $BOOTED_SLOT"
# Record the current booted slot in a temporary file that
# triggers the sync during shutdown (holo-post-update-shutdown.service)
if ! echo "$BOOTED_SLOT" > $HOLO_BOOTED_SLOT_SYNC_TRIGGER; then
    warn "Failed to record booted slot"
fi

case $BOOTED_SLOT in
    A)
        UPDATED_SLOT=B
        ;;
    B)
        UPDATED_SLOT=A
        ;;
    *)
        fail "Booted Slot is neither A nor B. Bailing."
        ;;
esac

log "Update slot candidate is $UPDATED_SLOT"

EFI_DEVICE_OTHER=$(realpath $SYMLINKS_DIR/other/efi)

log "Configuring the 'other' efi partition $EFI_DEVICE_OTHER " \
    "($BOOTED_SLOT -> $UPDATED_SLOT)"

[ -b "$EFI_DEVICE_OTHER" ] || \
    fail "Other efi device '$EFI_DEVICE_OTHER' not found"

mount "$EFI_DEVICE_OTHER" /mnt
configure_other_efi /mnt $BOOTED_SLOT $UPDATED_SLOT || \
    err "Failed to configure the 'other' efi"
umount /mnt

#
# Handle the 'other' var partition
#

ismounted() {
    local device=$1

    findmnt --real --source "$device" >/dev/null 2>&1
}

reformat_device_ext4() {
    local device=$1
    local opts=
    local label=

    device=$(readlink -f "$device")
    if ! [ -b "$device" ]; then
        warn "'$device' is not a block device"
        return
    fi

    if ismounted "$device"; then
        umount -v "$device"
    fi

    if ismounted "$device"; then
        umount -v -f "$device"
    fi

    label=$(e2label "$device")
    if [ "$label" ]; then
        opts="$opts -L $label"
    fi

    mkfs.ext4 -q -F $opts "$device"
}

log "Syncing the var partitions from 'self' to 'other'"

ROOTFS_DEVICE_OTHER=$(realpath $SYMLINKS_DIR/$UPDATED_SLOT/rootfs)
VAR_DEVICE_OTHER=$(realpath $SYMLINKS_DIR/$UPDATED_SLOT/var)
VAR_FROM=/var

[ -b "$VAR_DEVICE_OTHER" ] || \
    fail "Other var device '$VAR_DEVICE_OTHER' not found"

reformat_device_ext4 "$VAR_DEVICE_OTHER" || \
    err "Failed to reformat other var partition"

# Mount the rootfs device because we want to compare the upper /etc
# with the lowerdir
mount -o ro "$ROOTFS_DEVICE_OTHER" /mnt
mount "$VAR_DEVICE_OTHER" /mnt/var

# Sync /var partitions, including the /etc mountpoint, from the current image
#
/usr/lib/steamos/holo-sync-var all || \
    err "Failed to sync var partitions"

# Remove the old rootfs index to ensure that we either have the correct one
# or that we don't have it at all.
rm -f /mnt/var/lib/steamos-atomupd/rootfs.caibx
mkdir -p /mnt/var/lib/steamos-atomupd
cp "$RAUC_BUNDLE_MOUNT_POINT"/rootfs.img.caibx /mnt/var/lib/steamos-atomupd/rootfs.caibx || \
    warn "Failed to copy the rootfs seed index file"
umount /mnt/var
umount /mnt

#
# Handle the bootloaders and network configuration
#

log "Installing the bootloaders"
# any newer image should have finalize-install but a downgrade may be missing it;
# if so look for an older post-install script
steamos-chroot --partset $UPDATED_SLOT -- steamos-finalize-install --no-kernel || \
    steamos-chroot --partset $UPDATED_SLOT -- steamos-boot-install --no-kernel || \
    err "Failed to install bootloaders"

# Mark the new partition valid, otherwise it will not boot
# (note; you can't call rauc status mark-good here)
(( ERR == 0 )) && steamos-bootconf --image $UPDATED_SLOT set-mode reboot

# Store the installed update version in a temporary file to record that we
# have a pending reboot to switch to the new image
if [ $ERR == 0 ]; then
  update_manifest=$(steamos-chroot --partset $UPDATED_SLOT -- cat "/etc/steamos-atomupd/manifest.json")
  update_buildid=$(jq -r '.buildid | select(type == "string")' <<< "$update_manifest")
  update_version=$(jq -r '.version | select(type == "string")' <<< "$update_manifest")
  echo "${update_buildid}-${update_version}" > "$REBOOT_FOR_UPDATE"
  label=$(boot_label "$UPDATED_SLOT" "$update_manifest")
  if [ -n "${label:-}" ]; then
      steamos-chroot --partset $UPDATED_SLOT -- \
                     steamos-bootconf config --set title "${label:-}"
  fi
fi

if [[ $ERR != 0 ]]; then
    rm -f $HOLO_BOOTED_SLOT_SYNC_TRIGGER
fi
exit $ERR
