#!/bin/bash
# -*- mode: sh; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
# vim: et sts=4 sw=4

#  SPDX-License-Identifier: LGPL-2.1+
#
#  Copyright © 2019-2022 Collabora Ltd.
#  Copyright © 2019-2022 Valve Corporation.
#
#  This file is part of steamos-customizations.
#
#  steamos-customizations is free software; you can redistribute it and/or modify
#  it under the terms of the GNU Lesser General Public License as published
#  by the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

# Perform a factory reset
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> X <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
# NOTE: This is never a complete nuke-the-site-from-orbit reset
# a) we boot from /esp, so we can't really fix it as we
#    have nothing to fix it _from_
# b) likewise we don't reset the root fses as we haven't got a source
#    for a vanilla rootfs image
#
# The recovery tool/reset tool _does_ have vanilla data sources for those,
# so it is able to reset them.
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> X <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

declare -r FACTORY_RESET_CONFIG_DIR=@factory_reset_config_dir@
declare -r SYMLINKS_DIR=@udev_symlinks_absdir@
declare -r GRUB_CONFIG_RELPATH=@grub_config_relpath@
declare -i want_reset=0

. /lib/dracut-lib.sh
. /lib/steamos-grubconfig.sh

# when testing outside the initrd the base lib files are here:
# . /usr/lib/dracut/modules.d/99base/dracut-lib.sh
# . /usr/lib/dracut/modules.d/60steamos/steamos-grubconfig.sh

get_fs_uuid () {
    local -r dev=${1:-}
    local uuid=$(lsblk -l -n -d -o UUID $dev)

    echo "$uuid"
}

# These are the steps we need to take:
# a) get the fs uuid for the root fs
# b) mount "$device" on $efi_reset_mount
# c) generate new grub config at a staging location on $efi_reset_mount
# d) move the staged config to the real location if c succeeded
reset_efi() {
    local -r dev=${1:-}
    local -r path=${2:-}
    local -r img=${path##*/efi-}
    local -r rdev=/dev/disk/by-partsets/$img/rootfs
    local -r rootfs_uuid=$(get_fs_uuid $rdev)
    local -r default_kernel=/boot/vmlinuz-linux-neptune
    local -r default_initrd=/boot/initramfs-linux-neptune.img
    local kernel=
    local initrd=
    local ucode=
    local rdev_mount=

    info "Checking $img root device $rdev (fsuuid: $rootfs_uuid)"
    if ! ismounted $rdev; then
        rdev_mount=$(mktemp -d)
        info "Mounting rootfs $img to check for kernel"
        mount -o ro $rdev $rdev_mount
    fi

    local finfo=
    local maybe=
    # pick an actual kernel image from the rootfs
    while read maybe; do
        finfo=$(file -bL $rdev_mount/$maybe)
        info "Checking /$maybe: $finfo"
        case $finfo in
            *kernel*executable*[Ii]mage*)
                kernel=/$maybe
                info "Found kernel $kernel"
                break
                ;;
        esac
    done < <(cd $rdev_mount && ls -1r boot/vmlin*)

    # find the initramfs and ucode images
    while read maybe; do
        info "Checking /$maybe"
        case $maybe in
            *-ucode.img)
                [ "$ucode" ] && continue;
                ucode=/$maybe
                info "Found ucode $ucode"
                ;;
            *.img)
                [ "$initrd" ] && continue;
                initrd=/$maybe
                info "Found initrd $initrd"
                ;;
        esac
        [ "$ucode" ] && [ "$initrd" ] && break
    done < <(cd $rdev_mount && ls -1r boot/*.img)

    if [ "$rdev_mount" ]; then
        sleep 3
        info "Unmounting rootfs $img"
        umount -f $rdev_mount
    fi

    # We're going to mount the efi partitions we want to scrub
    # here so that in the worst case (ie this breaks), we won't
    # leave the OS dealing with the wrong partition mounted at /efi
    local -r efi_reset_mount=$(mktemp -d)
    mkdir -p $efi_reset_mount

    # Note: when regenerating an /efi partition we need to know
    # the fs uuid (NOT the partition uuid or partition type uuid)
    # of the related rootfs

    local grubcfg=$efi_reset_mount/$GRUB_CONFIG_RELPATH
    if [ "$rootfs_uuid" ]; then
        mount $dev $efi_reset_mount
        info "Regenerating bootloader cfg with $fsuuid $kernel $initrd $ucode"

        if [ ! "$kernel" ] || [ ! "$initrd" ]; then
            info "Kernel ($kernel) or initrd ($initrd) missing"
            info "Image $img may not be bootable (not necessarily a problem)"
        fi

        print_grub_config \
            "$rootfs_uuid"  \
            ${kernel:-$default_kernel} \
            ${initrd:-$default_initrd} \
            "${ucode:-}" > $grubcfg.new

        if [ $? -eq 0 ]; then
            mv $grubcfg.new $grubcfg
        else
            warn "Failed to make new config for fs $rootfs_uuid at $grubcfg"
            warn "kernel: $kernel; initrd: $initrd${ucode:+ + }$ucode"
        fi
        sleep 3
        umount -f $efi_reset_mount
    else
        info "No root fs found for image $img, cannot reset bootloader"
    fi

    # stray unused mountpoint is untidy but not worth signalling an error:
    rmdir $efi_reset_mount || true
}

reset_device_ext4() {
    local device=$1
    local label=$2
    local fs_opts=(${@:3})
    local opts=(-qF)
    local features=
    local tmp=
    local mt_point=
    local mt_opts=

    device=$(readlink -f "$device")
    # not considering it an error if a device we were meant to wipe does not exist
    if ! [ -b "$device" ]; then
        return 0
    fi

    # can't have the device mounted while we reformat it
    # but we do want to save the mount opts if it is mounted
    local proc_dev proc_mnt proc_fs proc_opts proc_etc

    while read proc_dev proc_mnt proc_fs proc_opts proc_etc; do
        if [ "$device" != "$proc_dev" ]; then
            continue
        fi
        mt_point="$proc_mnt"
        mt_opts="$proc_opts"
        warn "Unmounting $device from $mt_point ($mt_opts)"
        umount -v "$device"
    done < /proc/mounts

    # try harder if it's still mounted
    if ismounted "$device"; then
        umount -v -f "$device"
    fi

    if ismounted "$device"; then
        warn "Could not unmount $device from $mt_point"
        return 1
    fi

    # NOTE: should be impossible to get a device w/o a label, yet regardless
    # no cached label, read from fs:
    if [ -z "$label" ]; then
        label=$(e2label "$device")
    fi

    if [ "$label" ]; then
        opts+=(-L "$label")
        if [ "$label" = "home" ]; then
            opts+=(-m 0)
        fi
    fi

    # use cached opts from FACTORY_RESET_CONFIG_DIR, alternatively read them
    # from the filesystem
    if [ ${#fs_opts[@]} -eq 0 ]; then
        read -r -a fs_opts < <(tune2fs -l "$device" | sed -n 's/^Filesystem features:\s*//p')
    fi

    # copy the important fs opts explicitly (currently just casefold):
    for tmp in "${features[@]}"; do
        if [ "$tmp" = "casefold" ]; then
            opts+=(-O casefold)
            break
        fi
    done

    info "Making ext4 filesystem on device $device (options: ${opts[*]})"
    mkfs.ext4 "${opts[@]}" "$device"
    if [ -n "$mt_point" ]; then
        warn "Remounting fresh fs on $device at $mt_point ($mt_opts)"
        mount ${mt_opts:+-o} $mt_opts "$device" "$mt_point"
    fi
}

cleanup_esp=0
if [ ! -d /esp/efi ]; then
    dev=$(readlink -f $SYMLINKS_DIR/all/esp)
    info "Checking ESP partition $dev"
    if ! ismounted $dev; then
        info "Mounting $dev at /esp"
        mkdir -p /esp
        mount $dev /esp
        cleanup_esp=1
    fi
fi

if [ -d $FACTORY_RESET_CONFIG_DIR ]; then
    for cfg in $FACTORY_RESET_CONFIG_DIR/*.cfg; do
        if [ -e "$cfg" ]; then
            want_reset=1
            break
        fi
    done
fi

# the bootloader can't generate the reset manifest for us, but it is now
# allowed to request a factory reset via the kernel command line:
if [ $want_reset -eq 0 ]
then
    want_reset=$(getarg 'steamos.factory-reset=')
    if [ "$want_reset" -gt 0 ]
    then
        steamos-factory-reset-config
    fi
fi

# leave dev partitions alone - they're not present on consumer-mode
# devices and they're a handy place from which to diagnose/fix/test
# if we're making changes to the factory reset and we make a mess:
for cfg in $FACTORY_RESET_CONFIG_DIR/*.cfg; do
    case $cfg in
        */*-dev.cfg)
            warn "Ignoring reset for development partition $cfg"
            rm -v $cfg
            ;;
    esac
done

if [ $want_reset -ne 1 ]; then
    if [ $cleanup_esp = "1" ]; then
        umount /esp
    fi
    return 0
fi

info "A factory reset has been requested."
# Make sure we bail out if the reset fails at any stage
# we do this to make sure the reset will be re-attempted
# or resumed if it does not complete here (possibly because
# the user got bored and leaned on the power button)

# There is a small chance of a reset loop occurring if the reset cannot complete
# for fundamental reasons (unable to format filesystem and so forth) BUT
#
# a) the device is probably hosed anyway if this happens
#
# b) we care more (for now) about doing a genuine reset to stop
#    leaking private data / things worth actual €£$¥ to the next owner
#    than we do about [hopefully] unlikely reset loops

# We want to reset each filesystem in parallel _but_ we must wait for
# them to finish as we have to release all fds before the pivot to the
# real sysroot happens:
# NOTE: the rootfs would need to be reset _before_ the EFI fs if we were
# handling it, as its fs uuid must be known for the EFI reset - but since
# we're not touching it everything is parallelisable:
declare -a WAIT_PIDS=()
declare -A RESET_DEV
for cfg in $FACTORY_RESET_CONFIG_DIR/*.cfg; do
    [ -r $cfg ] || continue

    while read type instance dev opts; do
        info "Processing manifest file $cfg (async)"
        name="${instance##*/}"
        case $type in
            EFI)
                info "Resetting bootloader config on $dev ($instance)"
                (reset_efi $dev $instance && rm -f "$cfg") &
                RESET_PID=$!
                WAIT_PIDS+=($RESET_PID)
                RESET_DEV[$RESET_PID]="$dev $name"
                ;;
            VAR|HOME)
                # these are slow so we want them done in parallel and async
                # BUT we need to wait until they're all done before proceeding
                info "Formatting data partition $dev ($instance)"
                (reset_device_ext4 $dev "$name" "$opts" && rm -f "$cfg") &
                RESET_PID=$!
                WAIT_PIDS+=($RESET_PID)
                RESET_DEV[$RESET_PID]="$dev $name"
                ;;
            *)
                warn "Unexpected SteamOS reset type $type ($instance, $dev)"
                rm -f "$cfg"
                ;;
        esac
    done < $cfg
done

while true; do
    wait -f -p WAITED_FOR -n
    rc=$?
    if [ $rc -eq 127 ]; then
        # nothing left to wait for.
        break;
    elif [ $rc -ne 0 ]; then
        warn "Reset of ${RESET_DEV[$WAITED_FOR]} failed, factory reset incomplete"
    else
        info "Reset of ${RESET_DEV[$WAITED_FOR]} complete"
    fi
done

info "Unmounting /esp"
if [ $cleanup_esp = "1" ]; then
    umount /esp
fi
